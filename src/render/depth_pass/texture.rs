use crate::render::{PointCloudRenderMode, PointCloudRenderModeOpt};
use bevy_color::LinearRgba;
use bevy_core_pipeline::core_3d::{AlphaMask3d, Camera3d, Opaque3d, Transmissive3d, Transparent3d};
use bevy_ecs::prelude::*;
use bevy_platform::collections::HashMap;
use bevy_render::camera::ExtractedCamera;
use bevy_render::prelude::*;
use bevy_render::render_phase::{ViewBinnedRenderPhases, ViewSortedRenderPhases};
use bevy_render::render_resource::TextureFormat::{R32Float, Rg32Float};
use bevy_render::render_resource::binding_types::texture_2d;
use bevy_render::render_resource::{
    BindGroup, BindGroupLayout, Extent3d, ShaderStages, TextureDescriptor, TextureDimension,
    TextureSampleType, TextureUsages, TextureView,
};
use bevy_render::renderer::RenderDevice;
use bevy_render::texture::{ColorAttachment, TextureCache};
use bevy_render::view::ExtractedView;

/// Textures that are written to by the prepass.
#[derive(Component)]
pub struct ViewDepthPrepassTextures {
    /// The depth texture generated by the prepass.
    pub depth: Option<ColorAttachment>,
    /// The size of the textures.
    pub size: Extent3d,
}

impl ViewDepthPrepassTextures {
    pub fn depth_view(&self) -> Option<&TextureView> {
        self.depth.as_ref().map(|t| &t.texture.default_view)
    }
}

pub fn prepare_depth_pass_textures(
    mut commands: Commands,
    mut texture_cache: ResMut<TextureCache>,
    render_device: Res<RenderDevice>,
    opaque_3d_phases: Res<ViewBinnedRenderPhases<Opaque3d>>,
    alpha_mask_3d_phases: Res<ViewBinnedRenderPhases<AlphaMask3d>>,
    transmissive_3d_phases: Res<ViewSortedRenderPhases<Transmissive3d>>,
    transparent_3d_phases: Res<ViewSortedRenderPhases<Transparent3d>>,
    views_3d: Query<(
        Entity,
        &ExtractedCamera,
        &ExtractedView,
        &Camera3d,
        &Msaa,
        Option<&PointCloudRenderMode>,
    )>,
) {
    // TODO remove this first for ?
    let mut render_target_usage = <HashMap<_, _>>::default();
    for (_, camera, extracted_view, camera_3d, _msaa, _) in &views_3d {
        if !opaque_3d_phases.contains_key(&extracted_view.retained_view_entity)
            || !alpha_mask_3d_phases.contains_key(&extracted_view.retained_view_entity)
            || !transmissive_3d_phases.contains_key(&extracted_view.retained_view_entity)
            || !transparent_3d_phases.contains_key(&extracted_view.retained_view_entity)
        {
            continue;
        };

        // Default usage required to write to the depth texture
        let usage: TextureUsages = camera_3d.depth_texture_usages.into();

        render_target_usage
            .entry(camera.target.clone())
            .and_modify(|u| *u |= usage)
            .or_insert_with(|| usage);
    }

    let mut depth_textures = <HashMap<_, _>>::default();
    for (entity, camera, _, _, msaa, point_cloud_render_mode) in &views_3d {
        let Some(physical_target_size) = camera.physical_target_size else {
            continue;
        };

        let size = Extent3d {
            depth_or_array_layers: 1,
            width: physical_target_size.x,
            height: physical_target_size.y,
        };

        let cached_depth_texture = depth_textures
            .entry(camera.target.clone())
            .or_insert_with(|| {
                let descriptor = TextureDescriptor {
                    label: Some("pcl_depth_pass_texture"),
                    size,
                    mip_level_count: 1,
                    sample_count: msaa.samples(),
                    dimension: TextureDimension::D2,
                    format: if point_cloud_render_mode.use_edl() { Rg32Float } else { R32Float },
                    usage: TextureUsages::RENDER_ATTACHMENT | TextureUsages::TEXTURE_BINDING,
                    view_formats: &[],
                };
                texture_cache.get(&render_device, descriptor)
            })
            .clone();

        commands.entity(entity).insert(ViewDepthPrepassTextures {
            depth: Some(ColorAttachment::new(
                cached_depth_texture,
                None,
                Some(LinearRgba::WHITE),
            )),
            size,
        });
    }
}

#[derive(Component)]
pub struct DepthPassViewBindGroup {
    pub value: BindGroup,
}

#[derive(Resource)]
pub struct DepthPassLayout {
    pub layout: BindGroupLayout,
}

impl FromWorld for DepthPassLayout {
    fn from_world(world: &mut World) -> Self {
        let render_device = world.resource::<RenderDevice>();

        DepthPassLayout {
            layout: render_device.create_bind_group_layout(
                "pcl_depth_layout",
                &vec![texture_2d(TextureSampleType::Depth).build(0, ShaderStages::FRAGMENT)],
            ),
        }
    }
}

// pub fn prepare_depth_view_bind_groups(
//     mut commands: Commands,
//     depth_pass_layout: Res<DepthPassLayout>,
//     render_device: Res<RenderDevice>,
//     views: Query<(Entity, &ViewDepthPrepassTextures)>,
// ) {
//     for (entity, prepass_textures) in &views {
//         let Some(depth_texture) = &prepass_textures.depth else {
//             warn!("No depth texture for {}", entity);
//             continue;
//         };
//
//         let depth_desc = TextureViewDescriptor {
//             label: Some("prepass_depth"),
//             aspect: TextureAspect::All,
//             ..default()
//         };
//
//         let depth_view = depth_texture.texture.texture.create_view(&depth_desc);
//
//         commands.entity(entity).insert(DepthPassViewBindGroup {
//             value: render_device.create_bind_group(
//                 "pcl_depth_view_bind_group",
//                 &depth_pass_layout.layout,
//                 &vec![
//                     BindGroupEntry {
//                         binding: 0,
//                         resource: depth_view.into_binding(),
//                     },
//                 ],
//             ),
//         });
//     }
// }
